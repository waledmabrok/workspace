import 'dart:async';
import 'package:flutter/material.dart';
import '../../core/data_service.dart';
import '../../core/db_helper_cart.dart';
import '../../core/db_helper_sessions.dart';
import '../../core/models.dart';
import 'dart:convert';

import '../../widget/dialog.dart';
import 'notification.dart';

class AdminSubscribersPagee extends StatefulWidget {
  const AdminSubscribersPagee({super.key});

  @override
  State<AdminSubscribersPagee> createState() => _AdminSubscribersPageState();
}

class _AdminSubscribersPageState extends State<AdminSubscribersPagee> {
  DateTime _selectedDate = DateTime.now();
  List<Session> _sessions = [];
  bool _loading = true;
  Timer? _uiTimer;
  Timer? _checkTimer;
  Future<void> checkExpiringSessions(
    BuildContext context,
    List<Session> allSessions,
  ) async {
    final now = DateTime.now();
    final expiring = <Session>[];
    final expired = <Session>[];

    for (var s in allSessions) {
      if (s.subscription == null) continue;
      if (s.end == null) continue;

      final remaining = s.end!.difference(now);

      if (remaining.inMinutes <= 0) {
        expired.add(s);
      } else if (remaining.inMinutes <= 60) {
        expiring.add(s);
      }
    }

    if (expiring.isNotEmpty || expired.isNotEmpty) {
      List<String> notifications = [];

      if (expiring.isNotEmpty) {
        notifications.add("‚ö†Ô∏è ŸÅŸäŸá ${expiring.length} ÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÇÿ±ÿ® ŸäÿÆŸÑÿµ");
      }

      if (expired.isNotEmpty) {
        notifications.add("‚õî ŸÅŸäŸá ${expired.length} ÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÜÿ™ŸáŸâ ÿÆŸÑÿßÿµ");
      }
      // ÿ•ÿ¥ÿπÿßÿ± ÿ®ÿ≥Ÿäÿ∑ ÿØÿßÿÆŸÑ ÿßŸÑÿ£ÿ®
      if (expiring.isNotEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text("‚ö†Ô∏è ŸÅŸäŸá ${expiring.length} ÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÇÿ±ÿ® ŸäÿÆŸÑÿµ"),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 4),
          ),
        );
      }

      if (expired.isNotEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text("‚õî ŸÅŸäŸá ${expired.length} ÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÜÿ™ŸáŸâ ÿÆŸÑÿßÿµ"),
            backgroundColor: Colors.red,
            duration: Duration(seconds: 4),
          ),
        );
      }

      // üîî ÿ£Ÿà ÿ™ŸÇÿØÿ± ÿ™ÿ≥ÿ™ÿÆÿØŸÖ flutter_local_notifications ÿπÿ¥ÿßŸÜ Ÿäÿ∏Ÿáÿ± ÿ•ÿ¥ÿπÿßÿ± ÿπ ÿßŸÑŸÜÿ∏ÿßŸÖ
    }
  }

  @override
  void initState() {
    super.initState();
    Timer.periodic(const Duration(minutes: 5), (_) {
      checkExpiringSessions(context, _sessions);
    });
    _loadSessions().then((_) => _applyDailyLimitForAllSessions());
    _uiTimer = Timer.periodic(const Duration(seconds: 1), (_) {
      if (mounted) setState(() {});
    });
    _checkTimer = Timer.periodic(const Duration(seconds: 30), (_) {
      if (!_loading) _applyDailyLimitForAllSessions();
    });
  }

  @override
  void dispose() {
    _uiTimer?.cancel();
    _checkTimer?.cancel();
    super.dispose();
  }

  double? _getSubscriptionProgress(Session s) {
    final end = _getSubscriptionEnd(s);
    if (end == null) return null;

    final total = end.difference(s.start).inMinutes;
    if (total <= 0) return null;

    final elapsed = getSessionMinutes(s); // ŸáŸÜÿß ÿ®Ÿäÿ™ÿ≠ÿ≥ÿ® ÿßŸÑŸàŸÇŸÅ ÿßŸÑŸÖÿ§ŸÇÿ™ ÿµÿ≠
    final progress = elapsed / total;
    return progress.clamp(0.0, 1.0);
  }

  Future<void> _saveSessionWithEvent(
    Session s,
    String action, {
    Map<String, dynamic>? meta,
  }) async {
    s.addEvent(action, meta: meta);
    await SessionDb.updateSession(s);
    if (mounted) setState(() {});
  }

  Future<void> _confirmAndConvertToPayg(
    Session s, {
    String reason = 'manual',
  }) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder:
          (_) => AlertDialog(
            title: const Text('ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿ•ŸÑŸâ ÿ≠ÿ±'),
            content: Text(
              'ŸáŸÑ ÿ™ÿ±ŸäÿØ ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ¨ŸÑÿ≥ÿ© "${s.name}" ÿ•ŸÑŸâ ÿ≥ÿπÿ± ÿßŸÑÿ≠ÿ± ÿßŸÑÿ¢ŸÜÿü ÿßŸÑÿ≥ÿ®ÿ®: $reason',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context, false),
                child: const Text('ÿßŸÑÿ∫ÿßÿ°'),
              ),
              ElevatedButton(
                onPressed: () => Navigator.pop(context, true),
                child: const Text('ÿ™ÿ≠ŸàŸäŸÑ'),
              ),
            ],
          ),
    );

    if (confirmed != true) return;

    if (s.subscription != null && s.savedSubscriptionJson == null) {
      s.savedSubscriptionJson = jsonEncode(s.subscription!.toJson());
    }
    s.subscription = null;
    s.type = 'ÿ≠ÿ±';
    s.addEvent('converted_to_payg', meta: {'reason': reason});
    await SessionDb.updateSession(s);
    if (mounted) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text('ÿ™ŸÖ ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿ•ŸÑŸâ ÿ≠ÿ±.')));
      setState(() {});
    }
  }

  void _maybeNotifyDailyLimitApproaching(Session s) {
    final plan = s.subscription;
    if (plan == null ||
        plan.dailyUsageType != 'limited' ||
        plan.dailyUsageHours == null)
      return;

    final spentToday = _minutesOverlapWithDate(s, DateTime.now());
    final allowedToday = plan.dailyUsageHours! * 60;
    final remaining = allowedToday - spentToday;

    if (remaining > 0 && remaining <= 10) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'ÿ™ÿ®ŸÇŸâ $remaining ÿØŸÇŸäŸÇÿ© ŸÖŸÜ ÿßŸÑÿ®ÿßŸÇÿ© ÿßŸÑŸäŸàŸÖ ‚Äî ÿ®ÿπÿØ ÿ∞ŸÑŸÉ ÿ≥ŸäŸÉŸÖŸÑ ÿπŸÑŸâ ÿ≥ÿπÿ± ÿßŸÑÿ≠ÿ±',
            ),
          ),
        );
      }

      Timer(Duration(minutes: remaining), () async {
        final idx = _sessions.indexWhere((x) => x.id == s.id);
        if (idx == -1) return;
        final stillSession = _sessions[idx];
        if (!mounted) return;

        final planNow = stillSession.subscription;
        if (planNow == null ||
            planNow.dailyUsageType != 'limited' ||
            planNow.dailyUsageHours == null)
          return;

        final newSpentToday = _minutesOverlapWithDate(
          stillSession,
          DateTime.now(),
        );
        final newRemaining = planNow.dailyUsageHours! * 60 - newSpentToday;
        if (newRemaining <= 0) {
          // ÿ™ÿ≠ŸàŸäŸÑ ÿ™ŸÑŸÇÿßÿ¶Ÿä (ÿ®ÿØŸàŸÜ ÿ™ÿ£ŸÉŸäÿØ) ŸÑÿ£ŸÜ ÿßŸÑŸàŸÇÿ™ ÿßŸÜÿ™ŸáŸâ
          if (stillSession.savedSubscriptionJson == null &&
              stillSession.subscription != null) {
            stillSession.savedSubscriptionJson = jsonEncode(
              stillSession.subscription!.toJson(),
            );
          }
          stillSession.subscription = null;
          stillSession.type = 'ÿ≠ÿ±';
          stillSession.addEvent(
            'converted_to_payg',
            meta: {'reason': 'daily_limit'},
          );
          await SessionDb.updateSession(stillSession);

          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text(
                  'ÿßŸÜÿ™ŸáŸâ ÿ≠ÿØ ÿßŸÑÿ®ÿßŸÇÿ© ÿßŸÑŸäŸàŸÖ. ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿßŸÑÿ¢ŸÜ ÿ™ÿπŸÖŸÑ ÿπŸÑŸâ ÿ≥ÿπÿ± ÿßŸÑÿ≠ÿ±.',
                ),
              ),
            );
            setState(() {});
          }
        }
      });
    }
  }

  Future<void> _loadSessions() async {
    setState(() => _loading = true);
    final data = await SessionDb.getSessions();
    for (var s in data) {
      try {
        s.cart = await CartDb.getCartBySession(s.id);
      } catch (_) {}
    }
    setState(() {
      _sessions = data;
      _loading = false;
    });
  }

  /*Future<void> _applyDailyLimitForAllSessions() async {
    final now = DateTime.now();
    final toUpdate = <Session>[];
    for (var s in List<Session>.from(_sessions)) {
      final plan = s.subscription;
      if (plan == null ||
          plan.dailyUsageType != 'limited' ||
          plan.dailyUsageHours == null)
        continue;

      final spentToday = _minutesOverlapWithDate(s, now);
      final allowedToday = plan.dailyUsageHours! * 60;

      if (spentToday >= allowedToday) {
        if (s.savedSubscriptionJson == null && s.subscription != null)
          s.savedSubscriptionJson = jsonEncode(s.subscription!.toJson());
        s.subscription = null;
        s.type = 'ÿ≠ÿ±';
        s.addEvent('converted_to_payg', meta: {'reason': 'daily_limit'});
        toUpdate.add(s);
      }
    }

    if (toUpdate.isNotEmpty) {
      for (var s in toUpdate) await SessionDb.updateSession(s);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              '${toUpdate.length} ÿ¨ŸÑÿ≥ÿ© ÿ™ÿ≠ŸàŸÑÿ™ ÿ•ŸÑŸâ ÿ≠ÿ± ŸÑÿ®ŸÑŸàÿ∫Ÿáÿß ÿßŸÑÿ≠ÿØ ÿßŸÑŸäŸàŸÖŸä',
            ),
          ),
        );
        setState(() {});
      }
    }
  }*/
  Future<void> _applyDailyLimitForAllSessions() async {
    final now = DateTime.now();
    debugPrint("‚è≥ [_applyDailyLimitForAllSessions] Checking at $now ...");

    final toUpdate = <Session>[];
    for (var s in List<Session>.from(_sessions)) {
      debugPrint(
        "‚û°Ô∏è Session ${s.name} (${s.id}) - type=${s.type}, sub=${s.subscription?.name}",
      );

      final plan = s.subscription;
      if (plan == null) {
        debugPrint("   ‚ùå no subscription, skip");
        continue;
      }
      if (plan.dailyUsageType != 'limited' || plan.dailyUsageHours == null) {
        debugPrint("   ‚ÑπÔ∏è unlimited or no daily limit, skip");
        continue;
      }

      final spentToday = _minutesOverlapWithDate(s, now);
      final allowedToday = plan.dailyUsageHours! * 60;
      debugPrint(
        "   üïí spentToday=$spentToday min / allowed=$allowedToday min",
      );

      if (spentToday >= allowedToday) {
        debugPrint("   üö® limit reached! converting to ÿ≠ÿ±");
        if (s.savedSubscriptionJson == null) {
          s.savedSubscriptionJson = jsonEncode(s.subscription!.toJson());
        }
        s.subscription = null;
        s.type = 'ÿ≠ÿ±';
        s.addEvent('converted_to_payg', meta: {'reason': 'daily_limit'});
        toUpdate.add(s);
      }
    }

    if (toUpdate.isNotEmpty) {
      for (var s in toUpdate) {
        debugPrint("üíæ updating DB for session ${s.name}");
        await SessionDb.updateSession(s);
      }
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              '${toUpdate.length} ÿ¨ŸÑÿ≥ÿ© ÿ™ÿ≠ŸàŸÑÿ™ ÿ•ŸÑŸâ ÿ≠ÿ± ŸÑÿ®ŸÑŸàÿ∫Ÿáÿß ÿßŸÑÿ≠ÿØ ÿßŸÑŸäŸàŸÖŸä',
            ),
          ),
        );
        setState(() {});
      }
    }
  }

  // ======== ÿßÿ≥ÿ™ÿ®ÿØŸÑ Ÿáÿ∞Ÿá ÿßŸÑÿØÿßŸÑÿ© ÿ®ÿßŸÑŸÉÿßŸÖŸÑ =========
  int _minutesOverlapWithDate(Session s, DateTime date) {
    final dayStart = DateTime(date.year, date.month, date.day);
    final dayEnd = dayStart.add(const Duration(days: 1));

    // ÿ®ÿØÿßŸäÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿßŸÑŸÅÿπŸÑŸäÿ©
    final actualStart = s.start;

    // ÿ•ÿ∞ÿß ÿ®ÿØÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿ®ÿπÿØ ŸÜŸáÿßŸäÿ© ÿßŸÑŸäŸàŸÖ ŸÅŸÑŸäÿ≥ ŸáŸÜÿßŸÉ ÿ™ÿØÿßÿÆŸÑ
    if (actualStart.isAfter(dayEnd)) return 0;

    // ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿ¨ŸÖŸàÿπ ÿßŸÑŸÉŸÑŸä ŸÑŸÑÿØŸÇÿßÿ¶ŸÇ ÿßŸÑÿ™Ÿä ŸÖÿ∂ÿ™ ŸÖŸÜÿ∞ ÿ®ÿØÿßŸäÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ© (ÿØŸÅÿßÿπŸä)
    final totalMinutes = getSessionMinutes(s);

    // ÿ®ŸÜÿßÿ° ŸÜŸáÿßŸäÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿßŸÑÿ™ŸÇÿØŸäÿ±Ÿäÿ© ŸÖŸÜ ÿ®ÿØÿßŸäÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ© + ÿØŸÇÿßÿ¶ŸÇ ŸÖÿ∂ÿ™
    var sessEndCandidate = actualStart.add(Duration(minutes: totalMinutes));

    // ŸÑÿß ÿ™ÿ≥ŸÖÿ≠ ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ÿßŸÑŸÜŸáÿßŸäÿ© ÿ£ÿ®ÿπÿØ ŸÖŸÜ "ÿßŸÑÿ¢ŸÜ" (ŸÑÿß ŸÜÿ≠ÿ≥ÿ® ŸàŸÇÿ™ ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑ)
    final now = DateTime.now();
    if (sessEndCandidate.isAfter(now)) sessEndCandidate = now;

    // ÿ•ÿ∞ÿß ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÖŸÜÿ™ŸáŸäÿ© ŸÅŸä ÿßŸÑÿ≠ŸÇŸÑ use s.end ÿ®ÿØŸÑ ÿßŸÑÿ≠ÿ≥ÿßÿ®
    if (s.end != null) {
      sessEndCandidate = s.end!;
      if (sessEndCandidate.isAfter(now)) sessEndCandidate = now;
    }

    // ŸÇŸäÿØ ÿßŸÑÿ®ÿØÿßŸäÿ© ŸàÿßŸÑŸÜŸáÿßŸäÿ© ÿØÿßÿÆŸÑ ÿ≠ÿØŸàÿØ ÿßŸÑŸäŸàŸÖ
    final sessStart = actualStart.isBefore(dayStart) ? dayStart : actualStart;
    final sessEnd =
        sessEndCandidate.isAfter(dayEnd) ? dayEnd : sessEndCandidate;

    if (sessEnd.isBefore(dayStart) || sessStart.isAfter(dayEnd)) return 0;

    final overlap = sessEnd.difference(sessStart).inMinutes;
    return overlap < 0 ? 0 : overlap;
  }

  int getSessionMinutes(Session s) {
    // ŸÇÿßÿπÿØÿ© ŸÖÿ®ÿØÿ¶Ÿäÿ© ŸÖŸÜ ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÖÿÆÿ≤ŸÜÿ© (ÿßŸÑÿ≤ŸÖŸÜ ÿßŸÑŸÖÿ¨ŸÖŸëÿπ ÿ≥ÿßÿ®ŸÇÿßŸã)
    int base = s.elapsedMinutes;
    if (base < 0) base = 0;

    // ÿ•ÿ∞ÿß ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÖŸàŸÇŸàŸÅÿ© (ŸÖÿ≠ÿ≥Ÿàÿ®ÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã) ŸÜÿ±ÿ¨ÿπ ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÖÿÆÿ≤ŸÜÿ© ŸÅŸÇÿ∑
    if (!s.isActive || s.isPaused) {
      return base;
    }

    // ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿ≠ÿßŸÑŸäÿßŸã ŸÜÿ¥ÿ∑ÿ© -> ŸÜÿ≠ÿ≥ÿ® ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ¨ÿßÿ±Ÿä ŸÖŸÜÿ∞ ÿ¢ÿÆÿ± resume (ÿ£Ÿà ŸÖŸÜÿ∞ start)
    final since = s.pauseStart ?? s.start;
    final running = DateTime.now().difference(since).inMinutes;
    final runningNonNegative = running < 0 ? 0 : running;

    final total = base + runningNonNegative;
    return total < 0 ? 0 : total;
  }

  DateTime? _getSubscriptionEnd(Session s) {
    final plan = s.subscription;
    if (plan == null || plan.isUnlimited) return null;
    final start = s.start;
    switch (plan.durationType) {
      case "hour":
        return start.add(Duration(hours: plan.durationValue ?? 0));
      case "day":
        return start.add(Duration(days: plan.durationValue ?? 0));
      case "week":
        return start.add(Duration(days: 7 * (plan.durationValue ?? 0)));
      case "month":
        return DateTime(
          start.year,
          start.month + (plan.durationValue ?? 0),
          start.day,
          start.hour,
          start.minute,
        );
      default:
        return null;
    }
  }

  String _formatMinutes(int minutes) {
    if (minutes <= 0) return "0ÿØ";
    final h = minutes ~/ 60;
    final m = minutes % 60;
    if (h > 0) return "${h}ÿ≥ ${m}ÿØ";
    return "${m}ÿØ";
  }

  double _calculateTimeChargeFromMinutes(int minutes) {
    final settings = AdminDataService.instance.pricingSettings;
    if (minutes <= settings.firstFreeMinutes) return 0;
    if (minutes <= 60) return settings.firstHourFee;
    final extraHours = ((minutes - 60) / 60).ceil();
    double amount =
        settings.firstHourFee + extraHours * settings.perHourAfterFirst;
    if (amount > settings.dailyCap) amount = settings.dailyCap;
    return amount;
  }

  Future<void> _toggleSession(Session s) async {
    // ÿßÿ∞ÿß ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿ®ÿßŸÇÿ©
    if (s.subscription != null) {
      if (!s.isActive) {
        s.isActive = true;
        s.isPaused = false;
        s.pauseStart = DateTime.now();
        await _saveSessionWithEvent(s, 'started');
        _maybeNotifyDailyLimitApproaching(s);
      } else if (s.isPaused) {
        s.isPaused = false;
        s.pauseStart = DateTime.now();
        await _saveSessionWithEvent(s, 'resumed');
        _maybeNotifyDailyLimitApproaching(s);
      } else {
        // ÿ•ŸäŸÇÿßŸÅ ÿ®ÿßŸÇÿ© ÿßŸÑÿ¢ŸÜ
        final since = s.pauseStart ?? s.start;
        final added = DateTime.now().difference(since).inMinutes;
        s.elapsedMinutes += added;
        s.isPaused = true;
        s.pauseStart = null;
        await _saveSessionWithEvent(s, 'paused', meta: {'addedMinutes': added});

        // ŸÜŸÅÿ≠ÿµ ÿßŸÑŸÖÿ™ÿ®ŸÇŸä ÿßŸÑŸäŸàŸÖŸä
        final plan = s.subscription;
        final spentToday = _minutesOverlapWithDate(s, DateTime.now());
        final allowedToday =
            (plan != null &&
                    plan.dailyUsageType == 'limited' &&
                    plan.dailyUsageHours != null)
                ? plan.dailyUsageHours! * 60
                : -1;

        if (plan != null && allowedToday > 0 && spentToday <= allowedToday) {
          // Ÿäÿ®ŸÇŸâ ÿ∂ŸÖŸÜ ÿßŸÑÿ®ÿßŸÇÿ©
          if (mounted)
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(
                  'ÿ™ŸÖ ÿßŸÑÿ•ŸäŸÇÿßŸÅ ‚Äî ÿ™ÿ®ŸÇŸâ ÿ∂ŸÖŸÜ ÿßŸÑÿ®ÿßŸÇÿ© (${_formatMinutes(allowedToday - spentToday)})',
                ),
              ),
            );
        } else {
          // ŸÑÿß ÿ®ÿßŸÇÿ© ŸÖÿ™ÿ®ŸÇŸäÿ© -> ÿ™ÿ≠ŸàŸäŸÑ ÿ•ŸÑŸâ ÿ≠ÿ± (ŸÜÿ∑ŸÑÿ® ÿ™ÿ£ŸÉŸäÿØ)
          await _confirmAndConvertToPayg(s, reason: 'exhausted_on_pause');
          // ÿ®ÿπÿØ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ ŸÜÿ≠ÿ≠ÿ™ÿ≥ÿ® ŸàŸÜÿ≠ÿµŸëŸÑ ÿ•ŸÜ ŸÑÿ≤ŸÖ
          await _chargePayAsYouGoOnStop(s);
        }
      }
    } else {
      // ÿßÿ∞ÿß ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿ≠ÿ± (payg)
      if (!s.isActive) {
        s.isActive = true;
        s.isPaused = false;
        s.pauseStart = DateTime.now();
        await _saveSessionWithEvent(s, 'started_payg');
      } else if (s.isPaused) {
        s.isPaused = false;
        s.pauseStart = DateTime.now();
        await _saveSessionWithEvent(s, 'resumed_payg');
      } else {
        final since = s.pauseStart ?? s.start;
        final added = DateTime.now().difference(since).inMinutes;
        s.elapsedMinutes += added;
        s.isPaused = true;
        s.pauseStart = null;
        await _saveSessionWithEvent(
          s,
          'paused_payg',
          meta: {'addedMinutes': added},
        );
        // ÿπŸÜÿØ ÿ•ŸäŸÇÿßŸÅ payg ŸÜÿ≠ÿ≥ÿ® ŸàŸÜÿ¨ŸÖÿπ
        await _chargePayAsYouGoOnStop(s);
      }
    }

    await SessionDb.updateSession(s);
    if (mounted) setState(() {});
  }

  Future<void> _chargePayAsYouGoOnStop(Session s) async {
    // ==== D) fixed minutesToCharge example (use in _chargePayAsYouGoOnStop)
    final totalMinutes = getSessionMinutes(s);
    final diff = totalMinutes - s.paidMinutes;
    final minutesToCharge = diff > 0 ? diff.toInt() : 0;
    if (minutesToCharge <= 0) return;

    final amount = _calculateTimeChargeFromMinutes(minutesToCharge);
    final sale = Sale(
      id: generateId(),
      description: 'ÿØŸÅÿπ ŸàŸÇÿ™ - ÿ¨ŸÑÿ≥ÿ© ${s.name}',
      amount: amount,
    );
    await AdminDataService.instance.addSale(
      sale,
      paymentMethod: 'cash',
      updateDrawer: true,
    );
    s.paidMinutes += minutesToCharge;
    s.addEvent('charged', meta: {'minutes': minutesToCharge, 'amount': amount});
    await SessionDb.updateSession(s);
    if (mounted)
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'ÿØŸèŸÅÿπÿ™ ${amount.toStringAsFixed(2)} ÿ¨ ŸÑŸàŸÇÿ™ ${_formatMinutes(minutesToCharge)}',
          ),
        ),
      );
  }

  Future<void> _restoreSavedSubscription(Session s) async {
    if (s.savedSubscriptionJson == null) return;
    try {
      final map = jsonDecode(s.savedSubscriptionJson!);
      final restored = SubscriptionPlan.fromJson(
        Map<String, dynamic>.from(map),
      );
      s.subscription = restored;
      s.savedSubscriptionJson = null;
      s.resumeNextDayRequested = false;
      s.resumeDate = null;
      if (!s.isActive) {
        s.isActive = true;
        s.pauseStart = DateTime.now();
      }
      s.addEvent('restored_subscription');
      await SessionDb.updateSession(s);
      setState(() {});
      if (mounted)
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('ÿ™ŸÖ ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ ÿ®ÿßŸÇÿ™ŸÉ')));
    } catch (e) {
      if (mounted)
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('ÿÆÿ∑ÿ£ ŸÅŸä ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑÿ®ÿßŸÇÿ©')));
    }
  }

  Widget _buildEventTile(Map<String, dynamic> ev) {
    final ts = ev['ts'] ?? '';
    final action = ev['action'] ?? '';
    final meta = ev['meta'] ?? {};
    String label = action;
    switch (action) {
      case 'started':
        label = 'ÿ®ÿØÿ£ÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ©';
        break;
      case 'resumed':
        label = 'ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ';
        break;
      case 'paused':
        label = 'ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™';
        break;
      case 'converted_to_payg':
        label = 'ÿ™ÿ≠ŸàŸäŸÑ ŸÑÿ≠ÿ±';
        break;
      case 'charged':
        label = 'ÿ™ÿ≠ÿµŸäŸÑ ŸàŸÇÿ™';
        break;
      case 'paid_now':
        label = 'ÿØŸÅÿπ ÿßŸÑÿ¢ŸÜ';
        break;
      case 'restored_subscription':
        label = 'ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿ®ÿßŸÇÿ©';
        break;
      case 'started_payg':
        label = 'ÿ®ÿØÿ£ÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ© (ÿ≠ÿ±)';
        break;
      case 'paused_payg':
        label = 'ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™ (ÿ≠ÿ±)';
        break;
      case 'resumed_payg':
        label = 'ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ (ÿ≠ÿ±)';
        break;
      default:
        label = action;
    }
    return ListTile(
      dense: true,
      title: Text(label),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(ts.toString()),
          if (meta != null && meta.isNotEmpty)
            Text(meta.toString(), style: const TextStyle(fontSize: 12)),
        ],
      ),
    );
  }

  Future<void> _pickDate(BuildContext context) async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2020),
      lastDate: DateTime(2100),
    );
    if (picked != null) {
      setState(() {
        _selectedDate = DateTime(picked.year, picked.month, picked.day);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    /*  final filteredSessions =
        _sessions.where((s) {
          final d = s.start;
          return d.year == _selectedDate.year &&
              d.month == _selectedDate.month &&
              d.day == _selectedDate.day;
        }).toList();*/
    final filteredSessions =
        _sessions.where((s) {
          final isSubscriber = s.subscription != null; // ŸÖÿ¥ÿ™ÿ±ŸÉ ŸÅŸÇÿ∑

          // ŸÑŸà ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÑÿ≥Ÿá ÿ¥ÿ∫ÿßŸÑÿ©ÿå ÿÆŸÑŸäŸáÿß ÿ™ÿ∏Ÿáÿ± ŸÅŸä ÿßŸÑŸäŸàŸÖ ÿßŸÑÿ≠ÿßŸÑŸä
          if (s.end == null) {
            return isSubscriber;
          }

          // ŸÑŸà ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿßŸÜÿ™Ÿáÿ™ÿå ŸÜÿ¥ŸàŸÅ ŸáŸÑ ÿ™ÿßÿ±ŸäÿÆŸáÿß Ÿäÿ∫ÿ∑Ÿä ÿßŸÑŸäŸàŸÖ ÿßŸÑŸÖÿÆÿ™ÿßÿ±
          final dayStart = DateTime(
            _selectedDate.year,
            _selectedDate.month,
            _selectedDate.day,
          );
          final dayEnd = dayStart.add(const Duration(days: 1));

          final sessionStart = s.start;
          final sessionEnd = s.end!;

          final overlaps =
              sessionStart.isBefore(dayEnd) && sessionEnd.isAfter(dayStart);

          return isSubscriber && overlaps;
        }).toList();

    // ÿßŸÑÿ¢ŸÜ ŸÜÿπÿ±ÿ∂ ŸÉŸÑ ÿßŸÑÿ¨ŸÑÿ≥ÿßÿ™ (ÿ≠ÿ™Ÿâ ÿßŸÑŸÑŸä ÿ™ÿ≠ŸàŸÑÿ™ ŸÑÿ≠ÿ±)ÿå ŸÑŸÉŸÜ ŸÜŸÖŸäŸëÿ≤ŸáŸÖ ÿ®ÿµÿ±ŸäÿßŸã.
    final list = _sessions.toList()..sort((a, b) => a.name.compareTo(b.name));

    return Scaffold(
      body:
          _loading
              ? const Center(child: CircularProgressIndicator())
              : Column(
                children: [
                  Padding(
                    padding: const EdgeInsets.all(12),
                    child: Row(
                      children: [
                        const Text("ÿπÿ±ÿ∂ ŸÑŸäŸàŸÖ: "),
                        const SizedBox(width: 8),
                        ElevatedButton.icon(
                          icon: const Icon(Icons.calendar_today),
                          label: Text(
                            "${_selectedDate.year}-${_selectedDate.month.toString().padLeft(2, '0')}-${_selectedDate.day.toString().padLeft(2, '0')}",
                          ),
                          onPressed: () async {
                            final picked = await showDatePicker(
                              context: context,
                              initialDate: _selectedDate,
                              firstDate: DateTime(2000),
                              lastDate: DateTime(2100),
                            );
                            if (picked != null) {
                              setState(() {
                                _selectedDate = DateTime(
                                  picked.year,
                                  picked.month,
                                  picked.day,
                                );
                              });
                            }
                          },
                        ),

                        const SizedBox(width: 12),
                        ElevatedButton(
                          onPressed:
                              () => setState(
                                () => _selectedDate = DateTime.now(),
                              ),
                          child: const Text("ÿßŸÑŸäŸàŸÖ"),
                        ),
                        Spacer(),
                        IconButton(
                          icon: const Icon(Icons.refresh),
                          onPressed: _loadSessions,
                        ),
                      ],
                    ),
                  ),
                  Expanded(
                    child:
                        list.isEmpty
                            ? const Center(child: Text('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ¨ŸÑÿ≥ÿßÿ™'))
                            : ListView.builder(
                              itemCount: filteredSessions.length,
                              itemBuilder: (ctx, i) {
                                final s = filteredSessions[i];
                                final plan = s.subscription;
                                final isSub = plan != null;
                                final spentToday = _minutesOverlapWithDate(
                                  s,
                                  _selectedDate,
                                );
                                final totalSoFar = getSessionMinutes(s);
                                // -------- DEBUG: ÿßŸÑÿµŸÇ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ± ŸáŸÜÿß ----------
                                /*      debugPrint(
                                  'DBG SESSION ${s.name} -> start=${s.start}, elapsedMinutesField=${s.elapsedMinutes}, totalSoFar=$totalSoFar, pauseStart=${s.pauseStart}, isPaused=${s.isPaused}, isActive=${s.isActive}',
                                );
                              */ // --------------------------------------------
                                final allowedToday =
                                    (isSub &&
                                            plan!.dailyUsageType == 'limited' &&
                                            plan.dailyUsageHours != null)
                                        ? plan.dailyUsageHours! * 60
                                        : -1;
                                final remaining =
                                    allowedToday > 0
                                        ? (allowedToday - spentToday)
                                        : -1;
                                final minutesToCharge =
                                    (totalSoFar - s.paidMinutes)
                                        .clamp(0, totalSoFar)
                                        .toInt();

                                // badge
                                final badge =
                                    isSub
                                        ? Chip(
                                          label: Text('ÿ®ÿßŸÇÿ©'),
                                          backgroundColor:
                                              Colors.green.shade300,
                                        )
                                        : Chip(
                                          label: Text('ÿ≠ÿ±'),
                                          backgroundColor: Colors.black,
                                        );

                                String stopButtonText = 'ÿ•ŸäŸÇÿßŸÅ';
                                if (s.isActive && !s.isPaused) {
                                  if (isSub &&
                                      allowedToday > 0 &&
                                      remaining > 0)
                                    stopButtonText = 'ÿ•ŸäŸÇÿßŸÅ (ŸáŸäŸÉŸÖŸÑ ŸÉÿ®ÿßŸÇÿ©)';
                                  else if (isSub)
                                    stopButtonText = 'ÿ•ŸäŸÇÿßŸÅ (ŸáŸäÿ®ÿØÿ£ ÿ≠ÿ±)';
                                  else
                                    stopButtonText = 'ÿ•ŸäŸÇÿßŸÅ';
                                }

                                return Card(
                                  margin: const EdgeInsets.symmetric(
                                    horizontal: 10,
                                    vertical: 6,
                                  ),
                                  child: Padding(
                                    padding: const EdgeInsets.all(8.0),
                                    child: Column(
                                      crossAxisAlignment:
                                          CrossAxisAlignment.start,
                                      children: [
                                        Row(
                                          mainAxisAlignment:
                                              MainAxisAlignment.spaceBetween,
                                          children: [
                                            Expanded(
                                              child: Column(
                                                crossAxisAlignment:
                                                    CrossAxisAlignment.start,
                                                children: [
                                                  Row(
                                                    children: [
                                                      Text(
                                                        s.name,
                                                        style: const TextStyle(
                                                          fontWeight:
                                                              FontWeight.bold,
                                                        ),
                                                      ),
                                                      const SizedBox(width: 8),
                                                      badge,
                                                      const SizedBox(width: 6),
                                                      if (s.savedSubscriptionJson !=
                                                          null)
                                                        const Icon(
                                                          Icons.bookmark,
                                                          size: 18,
                                                          color:
                                                              Colors.blueAccent,
                                                        ),
                                                    ],
                                                  ),
                                                  const SizedBox(height: 6),
                                                  if (allowedToday > 0)
                                                    Text(
                                                      'ŸÖÿ™ÿ®ŸÇŸä ÿßŸÑŸäŸàŸÖ: ${_formatMinutes(remaining)}',
                                                    ),
                                                  Text(
                                                    'ŸÖÿ∂Ÿâ ŸÉŸÑŸä: ${_formatMinutes(totalSoFar)}    ŸÖÿØŸÅŸàÿπ: ${_formatMinutes(s.paidMinutes)}',
                                                  ),
                                                  if (isSub)
                                                    Text(
                                                      'ÿ™ŸÜÿ™ŸáŸä ÿßŸÑÿ®ÿßŸÇÿ©: ${_getSubscriptionEnd(s)?.toLocal().toString().split('.').first ?? 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØÿ©'}',
                                                    ),
                                                ],
                                              ),
                                            ),
                                            Row(
                                              children: [
                                                // ÿ≤ÿ± ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ ÿ®ÿßŸÇÿ© (ŸÑŸà ŸÖÿ≠ŸÅŸàÿ∏ÿ© + ŸÅŸä ŸäŸàŸÖ ÿ¨ÿØŸäÿØ)
                                                if (s.savedSubscriptionJson !=
                                                    null) ...[
                                                  if (DateTime.now().year !=
                                                          s.start.year ||
                                                      DateTime.now().month !=
                                                          s.start.month ||
                                                      DateTime.now().day !=
                                                          s.start.day)
                                                    Padding(
                                                      padding:
                                                          const EdgeInsets.only(
                                                            right: 6.0,
                                                          ),
                                                      child: ElevatedButton(
                                                        onPressed:
                                                            () =>
                                                                _restoreSavedSubscription(
                                                                  s,
                                                                ),
                                                        child: const Text(
                                                          'ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ ÿ®ÿßŸÇÿ™ŸÉ',
                                                        ),
                                                      ),
                                                    ),
                                                ],

                                                const SizedBox(width: 6),

                                                // ÿ≤ÿ± ÿßŸÑÿ®ÿØÿ°/ÿßŸäŸÇÿßŸÅ ÿßŸÑŸÖŸàÿ≠ÿØ Ÿäÿ™ÿµÿ±ŸÅ ÿ®ÿ≠ÿ≥ÿ® ŸÜŸàÿπ ÿßŸÑÿ¨ŸÑÿ≥ÿ©
                                                ElevatedButton(
                                                  onPressed: () async {
                                                    if (!s.isPaused &&
                                                        s.isActive) {
                                                      // ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™
                                                      final since =
                                                          s.pauseStart ??
                                                          s.start;
                                                      final added =
                                                          DateTime.now()
                                                              .difference(since)
                                                              .inMinutes;
                                                      s.elapsedMinutes += added;
                                                      s.isPaused = true;
                                                      s.pauseStart = null;
                                                      await _saveSessionWithEvent(
                                                        s,
                                                        'paused',
                                                        meta: {
                                                          'addedMinutes': added,
                                                        },
                                                      );
                                                    } else if (s.isPaused) {
                                                      // ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ
                                                      s.isPaused = false;
                                                      s.pauseStart =
                                                          DateTime.now();
                                                      await _saveSessionWithEvent(
                                                        s,
                                                        'resumed',
                                                      );
                                                    }
                                                    await SessionDb.updateSession(
                                                      s,
                                                    );
                                                    setState(() {});
                                                  },
                                                  child: Text(
                                                    s.isPaused
                                                        ? 'ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ'
                                                        : 'ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™',
                                                  ),
                                                ),

                                                const SizedBox(width: 6),

                                                ElevatedButton(
                                                  onPressed: () {
                                                    final result = showDialog(
                                                      context: context,
                                                      builder: (
                                                        BuildContext context,
                                                      ) {
                                                        return ReceiptDialog(
                                                          session: s,
                                                        );
                                                      },
                                                    );

                                                    if (result == true) {
                                                      setState(() {
                                                        // üîÑ ŸáŸÜÿß ÿ™ÿπŸÖŸÑ ÿ™ÿ≠ÿØŸäÿ´ ŸÑŸÑÿµŸÅÿ≠ÿ© (ŸÖÿ´ŸÑÿßŸã ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿØÿ±ÿ¨ ÿ£Ÿà ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÑŸäÿ≥ÿ™ÿ©)
                                                      });
                                                    }
                                                  },

                                                  /* _showReceiptDialog(s),*/
                                                  child: const Text("ÿ™ŸÅÿßÿµŸäŸÑ"),
                                                ),
                                              ],
                                            ),
                                          ],
                                        ),
                                        const SizedBox(height: 8),
                                        if (_getSubscriptionProgress(s) !=
                                            null) ...[
                                          const SizedBox(height: 6),
                                          LinearProgressIndicator(
                                            value: _getSubscriptionProgress(s),
                                            backgroundColor: Colors.grey[300],
                                            color: Colors.blueAccent,
                                            borderRadius: BorderRadius.all(
                                              Radius.circular(12),
                                            ),
                                            valueColor: AlwaysStoppedAnimation<
                                              Color
                                            >(
                                              _getSubscriptionProgress(s)! < 0.5
                                                  ? Colors.green
                                                  : (_getSubscriptionProgress(
                                                            s,
                                                          )! <
                                                          0.8
                                                      ? Colors.orange
                                                      : Colors.red),
                                            ),
                                            minHeight: 8,
                                          ),
                                          Text(
                                            "${((_getSubscriptionProgress(s)! * 100).toStringAsFixed(0))}%",
                                            style: const TextStyle(
                                              fontSize: 15,
                                              color: Colors.white,
                                            ),
                                          ),
                                        ],
                                        ExpansionTile(
                                          title: const Text(
                                            'Timeline & ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ¨ŸÑÿ≥ÿ©',
                                          ),
                                          children: [
                                            Padding(
                                              padding: const EdgeInsets.all(
                                                8.0,
                                              ),
                                              child: Column(
                                                crossAxisAlignment:
                                                    CrossAxisAlignment.start,
                                                children: [
                                                  Text(
                                                    'ÿ®ÿØÿßŸäÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©: ${s.start.toLocal()}',
                                                  ),
                                                  if (s.pauseStart != null)
                                                    Text(
                                                      'ÿ¢ÿÆÿ± ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™: ${s.pauseStart!.toLocal()}',
                                                    ),
                                                  Text(
                                                    'Elapsed (ÿØŸÇŸäŸÇÿ©): ${getSessionMinutes(s)}',
                                                  ),
                                                  const SizedBox(height: 8),
                                                  const Text(
                                                    'ÿ≥ÿ¨ŸÑ ÿßŸÑÿ£ÿ≠ÿØÿßÿ´:',
                                                    style: TextStyle(
                                                      fontWeight:
                                                          FontWeight.bold,
                                                    ),
                                                  ),
                                                  if ((s.events).isEmpty)
                                                    const Padding(
                                                      padding: EdgeInsets.all(
                                                        8.0,
                                                      ),
                                                      child: Text(
                                                        'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ÿ≠ÿØÿßÿ´ ÿ®ÿπÿØ',
                                                      ),
                                                    ),
                                                  ...s.events.reversed
                                                      .map(
                                                        (ev) =>
                                                            _buildEventTile(ev),
                                                      )
                                                      .toList(),
                                                ],
                                              ),
                                            ),
                                          ],
                                        ),
                                      ],
                                    ),
                                  ),
                                );
                              },
                            ),
                  ),
                ],
              ),
    );
  }
}

/* Future<void> _showReceiptDialog(Session s) async {
    // ==== E) safer calculations in _showReceiptDialog (snippet)
    final totalMinutes = getSessionMinutes(s);
    final spentToday = _minutesOverlapWithDate(s, _selectedDate);
    int allowedToday = -1;
    if (s.subscription != null &&
        s.subscription!.dailyUsageType == 'limited' &&
        s.subscription!.dailyUsageHours != null) {
      allowedToday = s.subscription!.dailyUsageHours! * 60;
    }

    final minutesDiff = totalMinutes - s.paidMinutes;
    final minutesToCharge = minutesDiff > 0 ? minutesDiff.toInt() : 0;

    // continue with coveredByPlan / extraIfPayNow using safe min/max as above
    final extraNow =
        (allowedToday > 0)
            ? (spentToday - allowedToday).clamp(0, double.infinity).toInt()
            : 0;
    int coveredByPlan = 0;
    int extraIfPayNow = minutesToCharge;
    if (allowedToday > 0) {
      final priorSpentToday =
          (spentToday - minutesToCharge).clamp(0, spentToday).toInt();
      final remainingAllowanceBefore = (allowedToday - priorSpentToday).clamp(
        0,
        allowedToday,
      );
      coveredByPlan =
          (minutesToCharge <= remainingAllowanceBefore)
              ? minutesToCharge
              : remainingAllowanceBefore;
      extraIfPayNow = minutesToCharge - coveredByPlan;
    }
    final extraChargeEstimate = _calculateTimeChargeFromMinutes(extraIfPayNow);
    final productsTotal = s.cart.fold(0.0, (sum, item) => sum + item.total);
    final requiredNow = extraChargeEstimate + productsTotal;
    final remaining = allowedToday > 0 ? (allowedToday - spentToday) : -1;

    await showDialog(
      context: context,
      builder:
          (context) => AlertDialog(
            title: Text('ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿØŸÅÿπ - ${s.name}'),
            content: SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text("ÿßŸÑÿ≠ÿßŸÑÿ©: ${s.subscription != null ? 'ÿ®ÿßŸÇÿ©' : 'ÿ≠ÿ±'}"),
                  Text("ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ®ÿØÿßŸäÿ©: ${s.start.toLocal().toString()}"),
                  if (s.pauseStart != null)
                    Text(
                      "ÿ¢ÿÆÿ± ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™ ÿπŸÜÿØ: ${s.pauseStart!.toLocal().toString()}",
                    ),
                  Text("ŸÖÿ∂Ÿâ ŸÉŸÑŸä: ${_formatMinutes(totalMinutes)}"),
                  Text(' ŸÖÿØŸÅŸàÿπ: ${_formatMinutes(s.paidMinutes)}'),
                  if (s.subscription != null)
                    Text(
                      'ÿßŸÑŸÖÿ™ÿ®ŸÇŸä ŸÖŸÜ ÿßŸÑÿ®ÿßŸÇÿ©: ${_getSubscriptionEnd(s) != null ? _formatMinutes(_getSubscriptionEnd(s)!.difference(DateTime.now()).inMinutes) : "ÿ∫Ÿäÿ± ŸÖÿ≠ÿØŸàÿØ"}',
                    ),
                  if (s.subscription != null && _getSubscriptionEnd(s) != null)
                    Text(
                      'ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ: ${_getSubscriptionEnd(s)!.toLocal().toString().split(".").first}',
                    ),
                  if (allowedToday > 0)
                    Text('ÿßŸÑŸÖÿ™ÿ®ŸÇŸä ŸÖŸÜ ÿßŸÑŸäŸàŸÖ: ${_formatMinutes(remaining)}'),

                  if (allowedToday > 0)
                    Text(
                      "ÿßŸÑŸäŸàŸÖ: ${_formatMinutes(spentToday)} / ${_formatMinutes(allowedToday)}",
                    ),
                  if (extraNow > 0)
                    Text("‚õî ÿØŸÇÿßÿ¶ŸÇ ÿ≤ÿßÿ¶ÿØÿ© ÿßŸÑÿ¢ŸÜ: ${_formatMinutes(extraNow)}"),
                  const SizedBox(height: 10),
                  Text("ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™:"),
                  ...s.cart.map(
                    (item) => Text(
                      "${item.product.name} x${item.qty} = ${item.total} ÿ¨",
                    ),
                  ),
                  const SizedBox(height: 10),
                  Text("ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿßŸÑÿ¢ŸÜ: ${requiredNow.toStringAsFixed(2)} ÿ¨"),
                ],
              ),
            ),
            actions: [
              ElevatedButton(
                onPressed: () async {
                  s.paidMinutes += minutesToCharge;
                  s.addEvent(
                    'paid_now',
                    meta: {
                      'amount': requiredNow,
                      'minutesPaid': minutesToCharge,
                    },
                  );
                  await SessionDb.updateSession(s);
                  if (mounted)
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text(
                          "‚úÖ ÿ™ŸÖ ÿßŸÑÿØŸÅÿπ ${requiredNow.toStringAsFixed(2)} ÿ¨",
                        ),
                      ),
                    );
                  setState(() {});
                  Navigator.pop(context);
                },
                child: const Text("ÿßÿØŸÅÿπ ÿßŸÑÿ¢ŸÜ"),
              ),
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text("ÿ•ÿ∫ŸÑÿßŸÇ"),
              ),
            ],
          ),
    );
  }
  /* Future<void> _showReceiptDialog(
      Session s,
      double timeCharge,
      double productsTotal,
      int minutesToCharge,
      ) async {
    double discountValue = 0.0;
    String? appliedCode;
    final codeCtrl = TextEditingController();

    String paymentMethod = "cash"; // ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä: ŸÉÿßÿ¥
    final TextEditingController paidCtrl = TextEditingController();

    // üîπ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖŸÜÿ∑ŸÇ ÿ®ÿ™ÿßÿπ ÿßŸÑÿ®ÿßŸÇÿ©
    final totalMinutes = getSessionMinutes(s);
    final spentToday = _minutesOverlapWithDate(s, _selectedDate);

    int allowedToday = -1;
    if (s.subscription != null &&
        s.subscription!.dailyUsageType == 'limited' &&
        s.subscription!.dailyUsageHours != null) {
      allowedToday = s.subscription!.dailyUsageHours! * 60;
    }

    final minutesDiff = totalMinutes - s.paidMinutes;
    final minutesToChargeSafe = minutesDiff > 0 ? minutesDiff.toInt() : 0;

    final extraNow =
    (allowedToday > 0)
        ? (spentToday - allowedToday).clamp(0, double.infinity).toInt()
        : 0;
    int coveredByPlan = 0;
    int extraIfPayNow = minutesToChargeSafe;
    if (allowedToday > 0) {
      final priorSpentToday =
      (spentToday - minutesToChargeSafe).clamp(0, spentToday).toInt();
      final remainingAllowanceBefore = (allowedToday - priorSpentToday).clamp(
        0,
        allowedToday,
      );
      coveredByPlan =
      (minutesToChargeSafe <= remainingAllowanceBefore)
          ? minutesToChargeSafe
          : remainingAllowanceBefore;
      extraIfPayNow = minutesToChargeSafe - coveredByPlan;
    }

    final extraChargeEstimate = _calculateTimeChargeFromMinutes(extraIfPayNow);

    // üîπ ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÖÿ∑ŸÑŸàÿ® (ÿ≤ŸäÿßÿØÿ© ŸÅŸÇÿ∑ + ŸÖŸÜÿ™ÿ¨ÿßÿ™ - ÿÆÿµŸÖ)
    double finalTotal =
        extraChargeEstimate + productsTotal - discountValue;

    await showDialog(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              title: Text('ÿ•ŸäÿµÿßŸÑ ÿßŸÑÿØŸÅÿπ - ${s.name}'),
              content: SingleChildScrollView(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text("ÿßŸÑÿ≠ÿßŸÑÿ©: ${s.subscription != null ? 'ÿ®ÿßŸÇÿ©' : 'ÿ≠ÿ±'}"),
                    Text("ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸàŸÇÿ™: ${_formatMinutes(totalMinutes)}"),
                    Text("ŸÖÿØŸÅŸàÿπ ÿ≥ÿßÿ®ŸÇŸãÿß: ${_formatMinutes(s.paidMinutes)}"),

                    if (allowedToday > 0)
                      Text(
                        "ÿßŸÑŸäŸàŸÖ: ${_formatMinutes(spentToday)} / ${_formatMinutes(allowedToday)}",
                      ),
                    if (coveredByPlan > 0)
                      Text("‚úÖ ŸÖÿ™ÿ∫ÿ∑Ÿä ÿ®ÿßŸÑÿ®ÿßŸÇÿ©: ${_formatMinutes(coveredByPlan)}"),
                    if (extraIfPayNow > 0)
                      Text("‚õî ÿ≤ŸäÿßÿØÿ© ŸÖÿØŸÅŸàÿπÿ©: ${_formatMinutes(extraIfPayNow)}"),

                    const SizedBox(height: 10),
                    Text("ŸàŸÇÿ™ ÿ≤ÿßÿ¶ÿØ (ŸÅŸÑŸàÿ≥): ${extraChargeEstimate.toStringAsFixed(2)} ÿ¨"),
                    const SizedBox(height: 8),
                    Text("ŸÖŸÜÿ™ÿ¨ÿßÿ™: ${productsTotal.toStringAsFixed(2)} ÿ¨"),
                    const SizedBox(height: 12),

                    Row(
                      children: [
                        const Text("ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿØŸÅÿπ: "),
                        const SizedBox(width: 8),
                        DropdownButton<String>(
                          value: paymentMethod,
                          items: const [
                            DropdownMenuItem(value: "cash", child: Text("ŸÉÿßÿ¥")),
                            DropdownMenuItem(value: "wallet", child: Text("ŸÖÿ≠ŸÅÿ∏ÿ©")),
                          ],
                          onChanged: (val) {
                            if (val != null) {
                              setDialogState(() => paymentMethod = val);
                            }
                          },
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),

                    Text(
                      'ÿßŸÑŸÖÿ∑ŸÑŸàÿ®: ${finalTotal.toStringAsFixed(2)} ÿ¨',
                      style: const TextStyle(fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 8),

                    TextField(
                      controller: paidCtrl,
                      keyboardType: TextInputType.number,
                      decoration: const InputDecoration(
                        labelText: "ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÖÿØŸÅŸàÿπ",
                      ),
                      onChanged: (_) => setDialogState(() {}),
                    ),
                    const SizedBox(height: 8),

                    Builder(
                      builder: (_) {
                        final paidAmount =
                            double.tryParse(paidCtrl.text) ?? 0.0;
                        final diff = paidAmount - finalTotal;
                        String diffText;
                        if (diff == 0) {
                          diffText = '‚úÖ ÿØŸÅÿπ ŸÉÿßŸÖŸÑ';
                        } else if (diff > 0) {
                          diffText =
                          'üí∞ ÿßŸÑÿ®ÿßŸÇŸä ŸÑŸÑÿπŸÖŸäŸÑ: ${diff.toStringAsFixed(2)} ÿ¨';
                        } else {
                          diffText =
                          'üí∏ ÿπŸÑŸâ ÿßŸÑÿπŸÖŸäŸÑ: ${(diff.abs()).toStringAsFixed(2)} ÿ¨';
                        }
                        return Text(
                          diffText,
                          style: const TextStyle(fontWeight: FontWeight.bold),
                        );
                      },
                    ),
                  ],
                ),
              ),
              actions: [
                ElevatedButton(
                  onPressed: () async {
                    final paidAmount = double.tryParse(paidCtrl.text) ?? 0.0;
                    final diff = paidAmount - finalTotal;
                    if (paidAmount < finalTotal) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('‚ö†Ô∏è ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÖÿØŸÅŸàÿπ ÿ£ŸÇŸÑ ŸÖŸÜ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®.'),
                        ),
                      );
                      return;
                    }

                    // ‚úÖ ÿ≥ÿ¨ŸÑ ÿØŸÇÿßÿ¶ŸÇ ÿßŸÑÿØŸÅÿπ (ÿßŸÑÿ≤ŸäÿßÿØÿ© ŸÅŸÇÿ∑)
                    s.paidMinutes += minutesToCharge;
                    s.amountPaid += paidAmount;

                    setState(() {
                      s.isActive = false;
                      s.isPaused = false;
                    });
                    await SessionDb.updateSession(s);

                    final sale = Sale(
                      id: generateId(),
                      description:
                      'ÿ¨ŸÑÿ≥ÿ© ${s.name} | ${extraIfPayNow} ÿØŸÇŸäŸÇÿ© ÿ≤ŸäÿßÿØÿ© + ŸÖŸÜÿ™ÿ¨ÿßÿ™: ${productsTotal}',
                      amount: paidAmount,
                    );

                    await AdminDataService.instance.addSale(
                      sale,
                      paymentMethod: paymentMethod,
                      customer: _currentCustomer,
                      updateDrawer: paymentMethod == "cash",
                    );

                    Navigator.pop(context);

                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text(
                          '‚úÖ ÿØŸÅÿπ ${paidAmount.toStringAsFixed(2)} ÿ¨',
                        ),
                      ),
                    );
                  },
                  child: const Text("ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿØŸÅÿπ"),
                ),
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text("ÿ•ŸÑÿ∫ÿßÿ°"),
                ),
              ],
            );
          },
        );
      },
    );
  }*/
*/
